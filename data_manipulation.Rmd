---
title: "data_manipulation"
author: "Fang Liu"
date: "10/5/2021"
output: html_document
---

```{r setup}
library(tidyverse)

options(tibble.print_min = 3)

#load the litters data set and change names to lower snake case
litters_data = read_csv("./data/FAS_litters.csv", col_types = "ccddiiii")
litters_data = janitor::clean_names(litters_data)

#load the pups data set and change names to lower snake case
pups_data = read_csv("./data/FAS_pups.csv", col_types = "ciiiii")
pups_data = janitor::clean_names(pups_data)
```

## Select 
For a given analysis, you may only need a subset of the **columns** in a data table; extracting only what you need can helpfully de-clutter, especially when you have large data sets.
```{r select_examples}
select(litters_data, group, litter_number, gd0_weight, pups_born_alive)
select(litters_data, group:gd_of_birth) #the ':' specifies a range of columns to keep 
select(litters_data, -pups_survive) #use '-' to specify things we want to remove 
select(litters_data, GROUP = group, LiTtEr_NuMbEr = litter_number) #rename in the process 
```

If all you want to do is rename something, you can use **rename** instead of select. This will rename the variables you care about, and keep everything original:
```{r rename}
rename(litters_data, GROUP = group, LiTtEr_NuMbEr = litter_number)
```

There are some handy helper functions for select; read about all of them using ?select_helpers. I use starts_with(), ends_with(), and contains() often, especially when there variables are named with suffixes or other standard patterns. I also frequently use is **everything()**, which is handy for reorganizing columns without discarding anything:
```{r}
select(litters_data, starts_with("gd")) #prints out all the columns that start with gd (ex: gd0_weight)
select(litters_data, litter_number, pups_survive, everything())
relocate(litters_data, litter_number, pups_survive)
#relocate does a similar thing (sort of like rename)
```

#### Learning Assesemnt 
In the pups data, select the columns containing litter number, sex, and PD ears]
```{r}
select(pups_data, litter_number, sex, pd_ears)
```


## Filter
Some data tables will include rows you don’t need for your current analysis. Like select, the first argument to filter is the dataframe you’re filtering; all subsequent arguments are **logical** expressions. You will often filter using comparison operators (>, >=, <, <=, ==, and !=). You may also use **%in%** to detect if values appear in a set, and **is.na()** to find missing values. 
The logic operators are &, |, and negation using !

#### Examples: 
* gd_of_birth == 20
* pups_born_alive >= 2
* pups_survive != 4
* !(pups_survive == 4)
* group %in% c("Con7", "Con8")
* group == "Con7" & gd_of_birth == 20

A very common filtering step requires you to omit missing observations. You can do this with filter, but I recommend using drop_na from the tidyr package:
* drop_na(litters_data) will remove *ANY* row with a missing value
* drop_na(litters_data, wt_increase) will remove rows for which *wt_increase* is missing.

## Mutate
Sometimes you need to select columns; sometimes you need to change them or create new ones. You can do this using mutate.The example below creates a new variable measuring the difference between gd18_weight and gd0_weight and modifies the existing group variable.
```{r mutate_example}
mutate(litters_data,
  wt_gain = gd18_weight - gd0_weight,
  group = str_to_lower(group)
)
```

Note that:
* Your new variables can be functions of old variables
* New variables appear at the **end** of the dataset in the order that they are created
* You can overwrite old variables
* You can create a new variable and immediately refer to (or change) it
* Creating a new variable that does EXACTLY what you need can be a challenge, but the more functions you know about, the easier this gets.

## Arrange 
You can arrange the **rows** in your data according to the values in one or more **columns**:
```{r}
head(arrange(litters_data, group, pups_born_alive), 10)
#this arranges/order the litters_data based on the group and the # of pups born alive and print out 10 of the observations
```

## Piping (%>%)
Piping pass the result of one function call as an argument to the next function call.
```{r pipe}
litters_data = 
  read_csv("./data/FAS_litters.csv", col_types = "ccddiiii") %>%
  janitor::clean_names() %>%
  select(-pups_survive) %>%
  mutate(
    wt_gain = gd18_weight - gd0_weight,
    group = str_to_lower(group)) %>% 
  drop_na(wt_gain)
```
On Mac, use Cmd + Shift + M.
NOTE:  By default, the pipe will take the result of one function call and use that as the **first** argument of the next function call; by design, functions in dplyr will take a **tibble** as an input and return a tibble as a result.

#### Learning Assesement 
Write commands that loads the pups data, cleans the variable names, filters the data to include only pups with sex 1, removes the PD ears variable, creates a variable that indicates whether PD pivot is 7 or more days
```{r answer}
read_csv("./data/FAS_pups.csv", col_types = 'ciiiii') %>%
  janitor::clean_names() %>% 
  filter(sex == 1) %>% 
  select(-pd_ears) %>%
  mutate(pivot_greater = pd_pivot > 7)
```
